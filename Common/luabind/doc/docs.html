<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">

<html>
<head>
	<title>luabind beta documentation</title>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
	<link href="style.css" type="text/css" rel="stylesheet">
</head>

<body>

<p>This library is currently in public beta phase. This documentation should be considered beta as well.
Please report any grammatical corrections/spelling corrections.</p>

<h1>Table of contents</h1>

<ol>
	<li><a href="#intro">Introduction</a> 
	<ul>
		<li><a href="#features">features</a> 
		<li><a href="#compilers">tested compilers</a>
	</ul>
	<li><a href="#build">Building luabind</a> 
	<li><a href="#basic">Basic usage</a> 
	<li><a href="#scopes">Scopes</a> 
	<li><a href="#fun">Binding functions to lua</a> 
	<ul>
		<li><a href="#fun_overload">overloaded functions</a> 
		<li><a href="#fun_sigmatch">signature matching</a>
		<li><a href="#lua_fun">calling lua functions</a> 
	</ul>
	<li><a href="#bind_classes">Binding classes to lua</a> 
	<ul>
		<li><a href="#class_property">properties</a> 
		<li><a href="#class_enum">enums</a>
		<li><a href="#class_operator">operators</a>
		<li><a href="#class_derived">derived classes</a> 
		<li><a href="#class_smart_pointers">smart_pointers</a> 
	</ul>
	<li><a href="#object">Object</a>
	<ul>
		<li><a href="#object_iterators">iterators</a>
		<li><a href="#object_functions">related functions</a>
		<li><a href="#functor">functor</a>
	</ul>
	<li><a href="#class_lua" >Defining classes in lua</a> 
	<ul>
		<li><a href="#class_lua_derive">deriving in lua</a>
		<li><a href="#class_lua_operators">overloading operators</a>
		<li><a href="#class_lua_finalizers">finalizers</a>
	</ul>
	<li><a href="#exceptions">Exceptions</a>
	<li><a href="#policies" >Parameter policies</a> 
	<ul>
		<li><a href="#policies_copy">copy</a> 
		<li><a href="#policies_adopt">adopt</a>
		<li><a href="#policies_dependency">dependency</a>
		<li><a href="#policies_return_ref">return_reference_to</a>
		<li><a href="#policies_out">out_value</a>
		<li><a href="#policies_pure_out">pure_out_value</a>
		<li><a href="#policies_discard_result">discard_result</a>
		<li><a href="#policies_return_stl_iterator">return_stl_iterator</a>
		<li><a href="#policies_yield">yield</a>
		<li><a href="#policies_custom">custom</a>
		<li><a href="#policies_user_converter">user defined converter</a>
	</ul>
	<li><a href="#config">Configuration</a>
	<li><a href="#implementation_notes">Implementation notes</a>
	<li><a href="#error_messages">Error messages</a> 
	<li><a href="#faq">FAQ</a>
	<li><a href="#future">Future additions</a> 
	<li><a href="#issues">Known issues</a> 
	<li><a href="#acknowledgments">Acknowledgments</a> 
</ol>

<h1><a name="intro"></a>Introduction</h1>

<p>Luabind is a library that helps you create bindings 
between C++ and <a href="http://www.lua.org">lua</a>. It 
has the ability to expose functions and classes, written in C++, to lua. It will 
also supply the functionality to define classes in lua and let them derive from 
other lua classes or C++ classes. Lua classes can override virtual functions 
from their C++ base classes. It is written towards lua 5.0, and does not work 
with lua 4.</p>

<p>It is implemented utilizing template meta programming. 
That means that you don't need an extra preprocess pass to compile your project 
(it is done by the compiler). It also means you don't (usually) have to know the 
exact signature of each function you register, since the library will generate 
code depending on the compile-time type of the function (which includes the 
signature). The main drawback of this approach is that the compilation time will 
increase for the file that does the registration, it is therefore recommended 
that you register everything in the same cpp-file.</p>

<p>luabind is released under the terms of the
<a href="http://www.opensource.org/licenses/mit-license.php">MIT license</a>.</p>

<p>We are very interested in hearing about projects that use luabind, please let
us know about your project.</p>

<h2><a name="features"></a>features</h2>

<p>Luabind supports:</p>
<ul>
	<li>overloaded free functions 
	<li>C++ classes in lua 
	<ul>
		<li>overloaded member functions 
		<li>operators 
		<li>properties 
		<li>enums
	</ul>
	<li>lua functions in C++ 
	<li>lua classes in C++ 
	<li>lua classes (single inheritance) 
	<ul>
		<li>derives from lua or C++ classes 
		<li>override virtual functions from C++ classes
	</ul>
	<li>implicit casts between registered types 
	<li>best match signature matching 
	<li>return value policies and parameter policies
</ul>

<h2><a name="compilers"></a>tested compilers</h2>

<p>Luabind has been tested to work on the following 
compilers:</p>

<ul>
	<li>Visual Studio 7.1
	<li>Visual Studio 7.0 
	<li>Visual Studio 6.0 (sp 5) 
	<li>Intel C++ 6.0 (Windows)
	<li>GCC 2.95.3 (cygwin) 
	<li>GCC 3.0.4 (Debian/Linux) 
	<li>GCC 3.1 (SunOS 5.8) 
	<li>GCC 3.2 (cygwin) 
</ul>

<p>It has been confirmed not to work with:</p>

<ul>
	<li>GCC 2.95.2 (SunOS 5.8)
</ul>

<p>Metrowerks 8.3 (Windows) compiles but fails the const-test. This means that const member
functions are treated as non-const member functions.</p>

<p>If you have tried luabind with a compiler not listed here, let us know
your result with it.</p>

<h1><a name="build"></a>Building luabind</h1>

<p>To keep down the compilation-time luabind is built as a library. This means you
have to either build it and lika against it, or include its source files in your project.
You also have to make sure the <tt>luabind</tt> directory is somewhere in your compiler's
include path. It requires <a href="http://www.boost.org">boost</a> 1.30.0 to be installed
(only boost headers). It also requires that lua is installed.</p>

<p>There is a makefile in the root-directory that will build the library and the test program.
If you are using a UNIX-system (or cygwin) they will make it easy to build luabind as a static
library. If you are using Visual Studio it may be easier to include the files in the <tt>src</tt>
directory in your project.</p>

<p>When building luabind you have several options that may streamline the library to better suit
your needs. It is extremely important that your application has the same settings as the library
was built with. The available options are found in the <a href="#config">Configuration</a> section.</p>

<p>If you want to change the settings to differ from the default, it's recommended that you define
the settings on the commandline of all your files (in the project settings in visual studio).</p>

<h1><a name="basic"></a>Basic usage</h1>

<p>To use luabind, you must include <tt>lua.h</tt> and luabind's main header file.</p>

<pre>
extern "C"
{
#include "lua.h"
}

#include &lt;luabind/luabind.hpp&gt;
</pre>

<p>This includes support for both registering classes and functions. If you just want to
have support for functions or classes you can include <tt>&lt;luabind/function.hpp&gt;</tt>
and <tt>&lt;luabind/class.hpp&gt;</tt> separately.</p>

<pre>
#include &lt;luabind/function.hpp&gt;
#include &lt;luabind/class.hpp&gt;
</pre>

<p>The first thing you need to do is to call <tt>luabind::open(lua_State*)</tt> which will
register the functions to create classes from lua, and initialize some state-global
structures used by luabind. If you don't call this function you will hit asserts later in
the library. There is no corresponding close function because once a class has been registered
in lua, there really isn't any good way to remove it. Partly because any remaining instances
of that class relies on the class being there. Everything will be cleaned up when the state
is closed though.</p>

<p>Note that no luabind header will include <tt>"lua.h"</tt>, this is up to you. You have to include
it before any luabind header is included.</p>


<h1><a name="scopes"></a>Scopes</h1>

<p>Everything that gets registered in lua is registered in a namespace (lua tables) or in the global
scope (called module). All registrations must be surrounded by its scope. To define a module, the
<tt>luabind::module</tt> class is used. It is used like this:</p>

<pre>
module(L)
[
	// declarations
];
</pre>

<p>This will register all declared functions or classes in the global namespace in lua. If you want
to have a namespace for your module (like the standard libraries) you can give a name to the constructor,
like this:</p>

<pre>
module(L, "my_library")
[
	// declarations
];
</pre>

<p>Here all declarations will be put in the <tt>my_library</tt> table.</p>

<p>If you want nested namespaces you can use the <tt>luabind::namespace_</tt> class. It works exactly
as <tt>luabind::module</tt> except that it doesn't take a <tt>lua_State*</tt> in it's constructor.
An example of its usage could look like this:</p>

<pre>
module(L, "my_library")
[

// declarations

	namespace_("detail")
	[
		// library-private declarations
	]

];
</pre>

<p>As you might have figured out, the following declarations are equivalent:</p>

<pre>
module(L)
[
	namespace_("my_library")
	[
		// declarations
	]

];
</pre>

<pre>
module(L, "my_library")
[
	// declarations
];
</pre>

<p>Each declaration must be separated by a comma, like this:</p>

<pre>
module(L)
[
	def("f", &amp;f),
	def("g", &amp;g),
	class_&lt;A&gt;("A")
		.def(construcor&lt;int, int&gt;),
	def("h", &amp;h)
];
</pre>

<p>More about the actual declarations in the <a href="#fun">Binding functions to lua</a> and
<a href="#bind_classes" >Binding classes to lua</a> sections.</p>

<p>A word of caution, if you are in <b>really</b> bad need for performance, putting your functions
in tables will increase the lookup time.</p>

<h1><a name="fun"></a>Binding functions to lua</h1>

<p>To bind functions to lua you use the function <tt>luabind::def()</tt>. It has the following 
synopsis:</p>

<pre>
template&lt;class F, class policies&gt;
void def(const char* name, F f, const Policies&amp;);
</pre>

<ul>
	<li>name is the name the function will have within lua. 
	<li>F is the function pointer you want to register. 
	<li>The Policies parameter is used to describe how 
	parameters and return values are treated by the function, this is an optional 
	parameter. More on this in <a href="#policies" >parameter policies</a>.
</ul>

<p>An example usage could be if you want to register the 
function <tt>float std::sin(float)</tt>:</p>

<pre>
module(L)
[
	def("sin", &amp;std::sin)
];
</pre>

<h2><a name="fun_overload"></a>overloaded functions</h2>

<p>If you have more than one function with the same name, 
and want to register them in lua, you have to explicitly give the signature. 
This is to let C++ know which function you refer to. For example, if you have 
two functions, <tt>int&nbsp;f(const&nbsp;char*)</tt> and <tt>void&nbsp;f(int)</tt>.</p>

<pre>
module(L)
[
	def("f", (int(*)(const char*)) &amp;f),
	def(L, "f", (void(*)(int)) &amp;f)
];
</pre>

<h2><a name="fun_sigmatch"></a>signature matching</h2>

<p>luabind will generate code that checks the lua stack to 
see if the values there can match your functions' signatures. It will handle 
implicit typecasts between derived classes, and it will prefer matches with the 
least number of implicit casts. In a function call, if the function is 
overloaded and there's no overload that match the parameters better than the 
other, you have an ambiguity. This will spawn a run-time error, stating that the 
function call is ambiguous. A simple example of this is to register one function 
that takes an <tt>int</tt> and one that takes a <tt>float</tt>. Since lua don't distinguish between floats and 
integers, both will always match.</p>

<p>Since all overloads are tested, it will always find the 
best match (not the first match). This also means that it can handle situations 
where the only difference in the signature is that one member function is const 
and the other isn't. For example, if the following function and class is 
registered:</p>

<pre>
struct A
{
	void f();
	void f() const;
};

const A* create_a();

struct B: A {};
struct C: B {};

void g(A*);
void g(B*);
</pre>

<p>(note that <tt>create_a()</tt> would need an <a href="#policies_adopt" >adopt return value policy</a>. How to register classes is 
described in <a href="#bind_classes" >Binding classes to lua</a>).</p>

<p>And the following lua code is executed:</p>

<pre>
a1 = create_a()
a1:f() -- the const version is called

a2 = A()
a2:f() -- the non-const version is called

a = A()
b = B()
c = C()

g(a) -- calls g(A*)
g(b) -- calls g(B*)
g(c) -- calls g(B*)
</pre>

<h2><a name="lua_fun"></a>calling lua functions</h2>

<p>To call a lua function, you can either use <tt>call_function()</tt>, <tt>call_member()</tt>, an
<a href="#object"><tt>object</tt></a> or <a href="#functor"><tt>functor</tt></a>.</p>

<h3><tt>template&lt;class Ret&gt;<br>
Ret call_function(lua_State* L, const char* name, ...)</tt></h3>
<p>This calls the global function called <tt>name</tt>. This function can only call global lua functions. The
... represents a variable number of parameters that are sent to the lua function. This function call may
throw <tt>luabind::error</tt> if the function call fails.</p>

<p>The return value isn't actually <tt>Ret</tt> (the template parameter), but a proxy object that will do
the function call. This enables you to give policies to the call. You do this with the operator[]. You
give the policies within the brackets, like this:</p>

<pre>
int ret = call_function&lt;int&gt;(L, "a_lua_function", new complex_class())[ adopt(_1) ];
</pre>

<h3><tt>template&lt;class Ret&gt;<br>
Ret call_member(object&amp;, const char* name, ...)</tt></h3>
<p>This treats the given <tt>object</tt> as an instance of a class. The given name is the name of a member
function to call. The ... represents a variable number of parameters given to the function. This function may
throw <tt>luabind::error</tt> if the function call fails.</p>

<p>You can give policies to a member function call the same way as you do with <tt>call_function</tt>.</p>

<h1><a name="bind_classes"></a>Binding classes to lua</h1>

<p>To register classes you use a class called <tt>class_</tt>. Its name is supposed to resemble the C++ 
keyword, to make it look more intuitive. It has an overloaded member function 
<tt>def()</tt> that is used to register member functions, 
operators, constructors, enums and properties on the class. It will return its 
this-pointer, to let you register more members directly.</p>

<p>Let's start with a simple example. Consider the 
following C++ class:</p>

<pre>
class testclass
{
public:
	testclass(const std::string&amp; s): m_string(s) {}
	void print_string() { std::cout &lt;&lt; m_string &lt;&lt; "\n"; }
private:
	std::string m_string;
};
</pre>

<p>To register it with a lua environment, write as follows 
(assuming you are <tt>using namespace luabind</tt>):</p>

<pre>
module(L)
[
	class_&lt;testclass&gt;("testclass")
		.def(constructor&lt;const std::string&amp;&gt;())
		.def("print_string", &amp;testclass::print_string)
];
</pre>

<p>This will register the class with the name <tt>testclass</tt> and constructor that takes a string as 
argument and one member function with the name <tt>print_string</tt>.</p>

<pre>
-- instantiate the class
a = testclass('a string')

-- call the member function print_string on it
-- this will print 'a string' on stdout
a:print_string()
</pre>

<p>It is also possible to register free functions as member 
functions. The requirement on the function is that it takes a pointer, const 
pointer, reference or const reference to the class type as the first parameter. 
The rest of the parameters are the ones that are visible in lua, while the 
object pointer is given as the first parameter. If we have the following C++ 
code:</p>

<pre>
struct A
{
	int a;
};

int plus(A* o, int v) { return o-&gt;a + v; }
</pre>

<p>You can register the plus, function as if it was a 
member function on <tt>A</tt> like this:</p>

<pre>
class_&lt;A&gt;("A")
	.def("plus", &amp;plus)
</pre>

<p><tt>plus</tt> can now be called as 
a member function on A with one parameter, <tt>int</tt>. If 
the object pointer parameter is const, the function will act as if it was a 
const member function (it can be called on const objects).</p>

<h2><a name="class_property"></a>properties</h2>

<p>To register a global data member with a class is easily 
done. Consider the following class:</p>

<pre>
struct A
{
	int a;
};
</pre>

<p>This class is registered like this:</p>

<pre>
module(L)
[
	class_&lt;A&gt;("A")
		.def_readwrite("a", &amp;A::a)
];
</pre>

<p>Then it's both readable and writable. You can 
also register attributes as read-only.</p>

<pre>
module(L)
[
	class_&lt;A&gt;("A")
	.def_readonly("a", &amp;A::a)
];
</pre>

<p>You can also register getter and setter functions and 
make them look as if they were a public data member. Consider the following 
class:</p>

<pre>
class A
{
	void set_a(int x) { a_ = x; }
	int get_a() const { return a_; }
private:
	int a_;
};
</pre>

<p>It can be registered as if it had a public data member 
<tt>a</tt> like this:</p>

<pre>
class_&lt;A&gt;("A")
	.property("a", &amp;A::get_a, &amp;A::set_a)
</pre>

<p>This way the <tt>get_a()</tt> and 
<tt>set_a()</tt> functions will be called instead of just 
writing to the data member. If you want to make it read only you can just omit 
the last parameter.</p>

<h2><a name="class_enum"></a>enums</h2>

<p>If your class contains enumerated constants (enums), you 
can register them as well to make them available in lua. Note that they will not 
be type safe, all enums are integers in lua, and all functions that takes an 
enum, will accept any integer. You register them like this:</p>

<pre>
module(L)
[
	class_&lt;A&gt;("A")
		.enum_("constants")
		[
			value("my_enum", 4),
			value("my_2nd_enum", 7),
			value("another_enum", 6)
		]
];
</pre>

<p>In lua they are reached like any data member, except 
that they are read-only and reached on the class itself rather than on an 
instance of the class.</p>

<pre>
print(A.my_enum)
print(A.another_enum)
</pre>

<p>In this example the numbers 4 and 6 are printed.</p>

<h2><a name="class_operator"></a>operators</h2>

<p>The mechanism for registering operators on your class is 
pretty simple. You use a global name <tt>luabind::self</tt> 
to refer to the class itself and then you just write the operator expression 
inside the <tt>def()</tt> call. This class:</p>

<pre>
struct vec
{
	vec operator+(int s);
};
</pre>

<p>Is registered like this:</p>

<pre>
module(L)
[
	class_&lt;vec&gt;("vec")
		.def(self + int())
];
</pre>

<p>This will work regardless if your plus operator is 
defined inside your class or as a free function.</p>

<p>If you operator is <tt>const</tt> (or, when defined as a free function,
takes a const reference to the class itself) you have to use <tt>const_self</tt>
instead of <tt>self</tt>. Like this:</p>

<pre>
module(L)
[
	class_&lt;vec&gt;("vec")
		.def(const_self + int())
];
</pre>

<p>The operators supported are those available in lua:</p>

<ul>
	<li>+ 
	<li>- 
	<li>* 
	<li>/ 
	<li>^
	<li>&lt;
	<li>&lt;=
	<li>==
	<li>unary -
	<li>operator()
</ul>

<p>This means, no in-place operators. The equality operator (==) has a little
hatch, it will not be called if the references are equal. This means that
the == operator has to do pretty much what's it's expected to do.</p>

<p>In the above example the other operand type is 
instantiated by writing <tt>int()</tt>. If the operand type 
is a complex type that cannot easily be instantiated you can wrap the type in a 
class called <tt>other</tt>. For example:</p>

<p>To register this class, we don't want to instantiate a 
string just to register the operator.</p>

<pre>
struct vec
{
	vec operator+(std::string);
};
</pre>

<p>Instead we use the <tt>other</tt> 
wrapper like this:</p>

<pre>
module(L)
[
	class_&lt;vec&gt;("vec")
		.def(self + other&lt;std::string&gt;())
];
</pre>

<p>To register an application operator:</p>

<pre>
module(L)
[
	class_&lt;vec&gt;("vec")
		.def( self(int()) )
];
</pre>

<p>There's one special operator. In lua it's called <tt>__tostring</tt>,
it's not really an operator. It is used for converting objects to strings
in a standard way in lua. If you register this functionality, you will
be able to use the lua standard function <tt>tostring()</tt> for converting
you object to a string.</p>

<p>To implement this operator in C++ you should supply an
operator<tt>&lt;&lt;</tt> for <tt>ostream</tt>. Like this example:</p>

<pre>
class number {};

std::ostream&amp; operator&lt;&lt;(ostream&amp;, number&amp;);
</pre>

<pre>
module(L)
[
	class_&lt;number&gt;("number")
		.def(tostring(self))
];
</pre>


<h2><a name="class_derived"></a>derived classes</h2>

<p>If you want to register classes that derives from other 
classes, you can specify a template parameter <tt>bases&lt;&gt;</tt> to
the <tt>class_</tt> instantiation. The following hierarchy:</p>

<pre>
struct A {};
struct B: A{};
</pre>

<p>Would be registered like this:</p>

<pre>
module(L)
[
	class_&lt;A&gt;("A"),
	class_&lt;B, A&gt;("B")
];
</pre>

<p>If you have multiple inheritance you can specify more 
than one base. If <tt>B</tt> would also derive from a class 
<tt>C</tt>, it would be registered like this:</p>

<pre>
module(L)
[
	class_&lt;B, bases&lt;A, C&gt; &gt;("B")
];
</pre>

<p>Note that you can omit <tt>bases&lt;..&gt;</tt> when using single inheritance.</p>

<p>If you don't specify that classes derive from each 
other, luabind will not be able to implicitly cast pointers between the types. 
If for example, you forget to tell that <tt>B</tt> derives 
from <tt>A</tt> and we have a function with the following 
signature:</p>

<pre>
void f(A*);
</pre>

<p>The following code will not run:</p>

<pre>
b = B()
f(b) -- error, no function 'f' matches the arguments (B)
</pre>

<p>Because luabind doesn't know that a <tt>B*</tt> can be cast to an <tt>A*</tt>.</p>

<h2><a name="class_smart_pointers"></a>smart_pointers</h2> 

<p>When you register a class you can tell luabind that all instances of that class should be held
by some kind of smart pointer (<tt>boost::shared_ptr</tt> for instance). You do this by giving
the holder type as an extra template-parameter to the <tt>class_</tt> your constructing, like this:</p>

<pre>
module(L)
[
	class_&lt;A, boost::shared_ptr&lt;A&gt; &gt;("A");
];
</pre>

<p>You also have to supply two functions for your smart pointer. One that returns the type of const
version of the smart pointer type (<tt>boost::shared_ptr&lt;const A&gt;</tt> in this case). And one
function that extracts the raw pointer from the smart pointer. The first function is needed because
luabind has to allow the non-const&nbsp;-&gt;&nbsp;conversion when passing values from lua to C++. The second
function is needed when lua calls member functions on held types, the this pointer must be a raw
pointer, it is also needed to allow the smart_pointer&nbsp;-&gt;&nbsp;raw_pointer conversion from
lua to C++. They look like this:</p>

<pre>
namespace luabind
{
	template&lt;class T&gt;
	T* get_pointer(boost::shared_ptr&lt;T&gt;&amp; p) { return p.get(); }

	template&lt;class A&gt;
	boost::shared_ptr&lt;const A&gt;* get_const_holder(boost::shared_ptr&lt;A&gt;*)
	{
		return 0;
	}
}
</pre>

<p>The conversion that works are (given that B is a base class of A):</p>

<table>
	<tr>
		<td colspan="2"><h3>from lua to C++</h3></td>
	</tr>
	<tr>
		<td>holder_type&lt;A&gt;</td>
		<td>A*</td>
	</tr>
	<tr>
		<td>holder_type&lt;A&gt;</td>
		<td>B*</td>
	</tr>
	<tr>
		<td>holder_type&lt;A&gt;</td>
		<td>const A*</td>
	</tr>
	<tr>
		<td>holder_type&lt;A&gt;</td>
		<td>const B*</td>
	</tr>
	<tr>
		<td>holder_type&lt;A&gt;</td>
		<td>holder_type&lt;A&gt;</td>
	</tr>
	<tr>
		<td>holder_type&lt;A&gt;</td>
		<td>holder_type&lt;const A&gt;</td>
	</tr>
	<tr>
		<td>holder_type&lt;const A&gt;</td>
		<td>const A*</td>
	</tr>
	<tr>
		<td>holder_type&lt;const A&gt;</td>
		<td>const B*</td>
	</tr>
	<tr>
		<td>holder_type&lt;const A&gt;</td>
		<td>holder_type&lt;const A&gt;</td>
	</tr>
	<tr>
		<td colspan="2"><h3>from C++ to lua</h3></td>
	</tr>
	<tr>
		<td>holder_type&lt;A&gt;</td>
		<td>holder_type&lt;A&gt;</td>
	</tr>
	<tr>
		<td>holder_type&lt;const A&gt;</td>
		<td>holder_type&lt;const A&gt;</td>
	</tr>
	<tr>
		<td>const holder_type&lt;A&gt;&amp;</td>
		<td>holder_type&lt;A&gt;</td>
	</tr>
	<tr>
		<td>const holder_type&lt;const A&gt;&amp;</td>
		<td>holder_type&lt;const A&gt;</td>
	</tr>

</table>

<p>When using a holder type, it can be useful to know if the pointer is valid. For example when using
std::auto_ptr, the holder will be invalidated when passed as a parameter to a function. 
For this purpose there is a member of all object instances in luabind: <tt>__ok</tt>.<p>

<pre>

struct test {};
void f(std::auto_ptr&lt;test&gt;);

module(L)
[
	class_&lt;test&gt;("test")
		.def(constructor&lt;&gt;()),

	def("f", &amp;f)
];

a = test()
f(a)
print a.__ok -- prints false

</pre>

<h1><a name="object"></a>Object</h1>

<p>Since functions have to be able to take lua values (of variable type) we need a wrapper
around them. This wrapper is called <tt>luabind::object</tt>. If the function you register
takes an <tt>object</tt>, it will match any lua value. To use it, you need to include
<tt>&lt;luabind/object.hpp&gt;</tt>. The <tt>object</tt> class has the following synopsis:</p>

<pre>
class object
{
public:
	class iterator;
	class raw_iterator;
	class array_iterator;

	template&lt;class T&gt;
	object(lua_State*, const T&amp; value);
	object(const object&amp;);
	object(lua_State*);
	object();

	~object();
	
	iterator begin() const;
	iterator end() const;
	raw_iterator raw_begin() const;
	raw_iterator raw_end() const;
	array_iterator abegin() const;
	array_iterator aend() const;

	void set();
	lua_State* lua_state() const;
	void pushvalue() const;
	bool is_valid() const;
	operator bool() const;
	
	template&lt;class Key&gt;
	<i>&lt;implementation-defined&gt;</i> operator[](const Key&amp;);

	template&lt;class Key&gt;
	object at(const Key&amp;) const;

	template&lt;class Key&gt;
	object raw_at(const Key&amp;) const;

	template&lt;class T&gt;
	object&amp; operator=(const T&amp;);
	object&amp; operator=(const object&amp;);

	template&lt;class T&gt;
	bool operator==(const T&amp;) const;
	bool operator==(const object&amp;) const;
	bool operator&lt;(const object&amp;) const;
	bool operator&lt;=(const object&amp;) const;
	bool operator&gt;(const object&amp;) const;
	bool operator&gt;=(const object&amp;) const;
	bool operator!=(const object&amp;) const;

	void swap(object&amp;);
	int type() const;

	<i>&lt;implementation-defined&gt;</i> operator()();
	
	template&lt;class A0&gt;
	<i>&lt;implementation-defined&gt;</i> operator()(const A0&amp; a0);

	template&lt;class A0, class A1&gt;
	<i>&lt;implementation-defined&gt;</i> operator()(const A0&amp; a0, const A1&amp; a1);

	/* ... */
	
};
</pre>

<p>When you have a lua object, you can assign it a new value with the assignment operator (=). When
you do this, the <tt>default_policy</tt> will be used to make the conversion from C++ value to lua.
If your <tt>luabind::object</tt> is a table you can access its members through the operator[] or
the iterators. The value returned from the operator[] is a proxy object that can be used both
for reading and writing values into the table (using operator=). Note that it is impossible
to know if a lua value is indexable or not (lua_gettable doesn't fail, it succeeds or crashes).
This means that if you're trying to index something that cannot be indexed, you're on your own. Lua
will call its <tt>panic()</tt> function (you can define your own panic function using
<tt>lua_setpanicf</tt>). The <tt>at()</tt> and <tt>raw_at()</tt> functions returns the value
at the given table position (like operator[] but only for reading).<p>

<p>The ordinary <tt>object::iterator</tt> uses <tt>lua_gettable</tt> to extract the values from
the table, the standard way that will invoke metamethods if any. The <tt>object::raw_iterator</tt>
uses <tt>lua_rawget</tt> and <tt>object::array_iterator</tt> uses <tt>lua_rawgeti</tt>. The latter
will only iterate over numberical keys starting at 1 and continue until the first nil value.</p>

<p>The <tt>lua_state()</tt> function returns the lua state where this object is stored. If you want
to manipulate the object with lua functions directly you can push it onto the lua stack by calling
<tt>pushvalue()</tt>. And set the object's value by calling <tt>set()</tt>, which will pop the top
value from the lua stack and assign it to the object.</p>

<p>The operator== will run <tt>lua_equal()</tt>
on the operands and return its result.</p>

<p>The <tt>int type()</tt> member function will return the lua type of the object. It will return
the same values as <tt>lua_type()</tt>.</p>

<p>The <tt>is_valid</tt> function tells you whether the object has been initialized or not. When created
with its default constructor, objects are invalid. To make an object valid, you can assign it a value. If
you want to invalidate an object you can simply assign it an invalid object.</p>

<p>The <tt>operator bool()</tt>
isn't really an implicit cast to bool, but an implicit cast to a member pointer, since member pointers
don't have any arithmetic operators on them (which can cause hard to find errors). The functionality of
the cast-operator is equivalent to <tt>is_valid()</tt>. This means that:</p>

<pre>
object o;
// ...
if (o.is_valid())
{
	// ...
}
</pre>

<p>is equivalent to:</p>

<pre>
object o;
// ...
if (o)
{
	// ...
}
</pre>

<p>The application operator will call the value as if it was a function. You can give it any number
of parameters (currently the <tt>default_policy</tt> will be used for the conversion). The returned
object refers to the return value (currently only one return value is supported). This operator may
throw <tt>luabind::error</tt> if the function call fails. If you want to specify
<a href="#policies">policies</a> to your function call, you can use index-operator (operator[]) on
the function call, and give the policies within the [ and ]. Like this:</p>

<pre>
my_function_object(2, 8, new my_complex_structure(6)) [ adopt(_3) ];
</pre>

<p>This tells luabind to make lua adopt the ownership and responsibility for the pointer passed in
to the lua-function.</p>

<p>It's important that all instances of <tt>object</tt> have been destructed by the time the lua state
is closed. The object will keep a pointer to the lua state and release its lua object in its
destructor.</p>

<p>Here's an example of how a function can use a table.</p>

<pre>
void my_function(const object&amp; table)
{
	if (table.type() == LUA_TTABLE)
	{
		table["time"] = std::clock();
		table["name"] = std::rand() &lt; 500 ? "unusual" : "usual";

		std::cout &lt;&lt; object_cast&lt;std::string&gt;(table[5]) &lt;&lt; "\n";
	}
}
</pre>

<p>If you take a <tt>luabind::object</tt> as a parameter to a function, any lua value will match that parameter.
That's why we have to make sure it's a table before we index into it.</p>

<h2><a name="object_iterators"></a>iterators</h2>

<p>The iterators, that are returned by the <tt>begin()</tt> and <tt>end()</tt> (and their variants) are (almost)
models of the <a href="http://www.sgi.com/tech/stl/ForwardIterator.html">
ForwardIterator</a> concept. The exceptions are that operator-&gt; and post increment doesn't exist on
them.</p>

<p>They look like this:</p>

<pre>
class object::iterator
{
	iterator();
	iterator(const iterator&amp;);
	
	iterator&amp; operator++();
	bool operator!=(const iterator&amp;) const;
	iterator&amp; operator=(const iterator&amp;);

	object key() const;

	<i>implementation-defined</i> operator*();
};
</pre>

<p>The implementation defined return value from the dereference operator is a proxy object that can be used as if it was
an <tt>object</tt>, it can also be used to assign the specific table entry with a new value. If you want to assign a
value to an entry pointed to by an iterator, just use the assignment operator on the dereferenced iterator:</p>

<pre>
*iter = 5;
</pre>

<p>The <tt>key()</tt> member returns the key used by the iterator when indexing the associated lua table.</p>

<h2><a name="object_functions"></a>related functions</h2>

<p>
There are a couple of functions related to objects and tables.
</p>

<h3><tt>T object_cast&lt;<i>Type</i>&gt;(const&nbsp;object&amp;);</tt><br>
<tt>T object_cast&lt;<i>Type</i>&gt;(const&nbsp;object&amp;, const&nbsp;Policies&amp;);</tt><br>
<tt>boost::optional&lt;T&gt; object_cast_nothrow&lt;<i>Type</i>&gt;(const&nbsp;object&amp;);</tt><br>
<tt>boost::optional&lt;T&gt; object_cast_nothrow&lt;<i>Type</i>&gt;(const&nbsp;object&amp;, const&nbsp;Policies&amp;);</tt></h3>
<p>The <tt>object_cast</tt> function casts the value of an <tt>object</tt> to a C++ value. You
can supply a policy to handle the conversion from lua to C++. If the cast cannot be made a
<tt>cast_failed</tt> exception will be thrown. If you have defined <tt>LUABIND_NO_ERROR_CHECKING</tt>
(see <a href="#config">configuration</a>) no checking will occur, and if the cast is invalid the
application may very well crash. The nothrow versions will return an uninitialized <tt>boost::optional&lt;T&gt;</tt>
object, to indicate that the cast could not be performed.</p>

<h3><tt>object get_globals(lua_State*);</tt><br>
<tt>object get_registry(lua_State*);</tt></h3>
<p>These functions return the global environment table and the registry table respectively.</p>

<h3><tt>object newtable(lua_State*);</tt></h3>
<p>This function creates a new table and returns an object to it.</p>

<h2><a name="functor"></a>functor</h2>

<p>The <tt>functor</tt> class is similar to <tt>object</tt>, with the exception that it can
only be used to store functions. If you take it as a parameter, it will only match functions.</p>

<p>To use it you need to include its header:</p>

<pre>
#include &lt;luabind/functor.hpp&gt;
</pre>

<p>It takes one template parameter, the return value of the lua function it represents.
Currently the functor can have at most one return value (unlike lua functions). It has the
following synopsis:</p>

<pre>
template&lt;class Ret&gt;
class functor
{
public:

	functor(lua_State*, const char* name);
	functor(const functor&amp;);

	~functor();
	
	bool is_valid() const;
	operator bool() const;

	lua_State* lua_state() const;
	void pushvalue() const;
	
	bool operator==(const functor&lt;Ret&gt;&amp;);
	bool operator!=(const functor&lt;Ret&gt;&amp;);
	
	<i>&lt;implementation-defined&gt;</i> operator()() const;
	
	template&lt;class A0&gt;
	<i>&lt;implementation-defined&gt;</i> operator()(const A0&amp;) const;

	template&lt;class A0, class A1&gt;
	<i>&lt;implementation-defined&gt;</i> operator()(const A0&amp;, const A1&amp;) const;

	/* ... */
};
</pre>

<p>The application operator takes any parameters. The parameters are converted into lua and the 
function is called. The return value will act as if it was the type <tt>Ret</tt>, with the exception that you can use the
return value to give policies to the call. You do this the same way as you do with <a href="#object">objects</a>,
using the operator[], and giving the policies inside the brackets.</p>

<p>The <tt>is_valid()</tt> function works just like the one on <a href="#object"><tt>object</tt></a>, it tells you if
the functor has been assigned with a valid lua function. The <tt>operator bool()</tt> is an alias for this member function
and also works just as the one found in <a href="#object"><tt>object</tt></a>.</p>

<p>For example, if you have the following lua function:</p>

<pre>
function f(a, b)
	return a + b
end
</pre>

<p>You can expose it to C++ like this:</p>

<pre>
functor&lt;int&gt; f(L, "f");

std::cout &lt;&lt; f(3, 5) &lt;&lt; "\n";
</pre>

<p>This will print out the sum of 3 and 5. Note that you can pass any parameters to the
application operator of <a href="#functor"><tt>luabind::functor</tt></a>, this is because lua doesn't have 
signatures for its functions. All lua functions take any number of parameters 
of any type.</p>

<p>If we have a C++ function that takes a <a href="#functor"><tt>luabind::functor</tt></a> and registers it, it will accept lua 
functions passed to it. This enables us to expose APIs that requires you to 
register callbacks. For example, if your C++ API looks like this:</p>

<pre>
void set_callback(void(*)(int, int));
</pre>
	
<pre>
object o;
// ...
if (o.is_valid())
{
	// ...
}
</pre>


<p>And you want to expose it to lua, you have to wrap the 
call to the lua function inside a real C++ function, like this:</p>

<pre>
functor&lt;void&gt; lua_callback;

void callback_wrapper(int a, int b)
{
	lua_callback(a, b);
}

void set_callback_wrapper(const functor&lt;void&gt;&amp; f)
{
	lua_callback = f;
	set_callback(&amp;callback_wrapper);
}
</pre>

<p>And then register <tt>set_callback_wrapper</tt> instead of registering <tt>set_callback</tt>.
This will have the effect that when one tries to register the callback from lua, your
<tt>set_callback_wrapper</tt> will be called instead and first set the lua functor to the given function.
It will then call the real <tt>set_callback</tt> with the <tt>callback_wrapper</tt>. The
<tt>callback_wrapper</tt> will be called whenever the callback should be called, and it will simply
call the lua function that we registered.</p>

<p>You can also use <a href="#object_functions"><tt>object_cast</tt></a> to cast an object to a <a href="#functor"><tt>functor</tt></a>.</p>

<h1><a name="class_lua"></a>Defining classes in lua</h1>

<p>In addition to binding C++ functions and classes with 
lua, luabind also provide an oo-system in lua.</p>

<pre>
class 'lua_testclass'

function lua_testclass:__init(name)
	self.name = name
end

function lua_testclass:print()
	print(self.name)
end

a = lua_testclass('example')
a:print()
</pre>

<p>Inheritance can be used between lua-classes:</p>

<pre>
class 'derived' (lua_testclass)

function derived:__init() super('derived name')
end

function derived:print()
	print('Derived:print() -&gt; ')
	lua_testclass.print(self)
end
</pre>

<p>Here the <tt>super</tt> keyword is 
used in the constructor to initialize the base class. The user is required to 
call <tt>super</tt> first in the constructor.</p>

<p>As you can see in this example, you can call the 
base class' member functions. You can find all member functions in the base class, 
but you will have to give the this-pointer (<tt>self</tt>) as first argument.</p>

<h2><a name="class_lua_derive"></a>deriving in lua</h2>

<p>It is also possible to derive lua classes from C++ 
classes, and override virtual functions with lua functions. To do this we have 
to create a wrapper class for our C++ base class. This is the class that will 
hold the lua object when we instantiate a lua class.</p>

<p>The wrapper class has to provide the same constructors 
as the base class, with the addition of one extra parameter: <tt>luabind::object</tt>.
This is the reference to the lua object that should be held by the wrapper, and should
be stored in a member variable as done in the sample below.</p>

<pre>
class base class
{
public:
	baseclass(const char* s)	{ std::cout &lt;&lt; s &lt;&lt; "\n"; }
	virtual void f(int a) { std::cout &lt;&lt; "f(" &lt;&lt; a &lt;&lt; ")\n"; }
};

struct baseclass_wrapper: baseclass
{
	luabind::object m_l;
	baseclass_wrapper(luabind::object l, const char* s): baseclass(s), m_l(l) {}

	virtual void f(int a) { call_member&lt;void&gt;(m_l, "f", a); }
	static void f_static(baseclass* ptr, int a)
	{
		return ptr-&gt;baseclass::f(a);
	}
};
</pre>
<pre>
module(L)
[
	class_&lt;baseclass, baseclass_wrapper&gt;("baseclass")
		.def(constructor&lt;const char*&gt;())
		.def("f", &amp;baseclass_wrapper::f_static)
];	
</pre>

<p>Note that if you have both base classes and a base class 
wrapper, you must give both <tt>bases</tt> and the 
base class wrapper type as template parameter to <tt>class_</tt>. The order
in which you specify them is not important.</p>

<p>If we didn't have a class wrapper, it would not be possible to pass a lua class
back to C++. Since the entry points of the virtual functions would still point to
the C++ base class, and not to the functions defined in lua. That's why we need
one function that calls the base class' real function (used if the lua class
doesn't redefine it) and one virtual function that dispatches the call into luabind,
to allow it to select if a lua function should be called, or if the original
function should be called. If you don't intend to derive from a C++ class, or if
it doesn't have any virtual member functions, you can register it without a
class wrapper.</p>

<p>You don't need to have a class wrapper in order to derive from a class,
but if it has virtual functions you may have silent errors. The rule of thumb is:
If your class has virtual functions, create a wrapper type, if it doesn't don't create
a wrapper type.</p>

<h2><a name="class_lua_operators"></a>overloading operators</h2>

<p>You can overload most operators in lua for your classes. You do this by simply declaring
a member function with the same name as an operator (the name of the metamethods in lua). The operators
you can overload are:</p>

<ul>
	<li><tt>__add</tt>
	<li><tt>__sub</tt>
	<li><tt>__mul</tt>
	<li><tt>__div</tt>
	<li><tt>__pow</tt>
	<li><tt>__lt</tt>
	<li><tt>__le</tt>
	<li><tt>__eq</tt>
	<li><tt>__call</tt>
	<li><tt>__unm</tt>
	<li><tt>__tostring</tt>
</ul>

<p><tt>__tostring</tt> isn't really an operator, but it's the metamethod that is called by the standard
library's <tt>tostring()</tt> function. There's one strange behavior regarding binary operators. You are not
guaranteed that the self pointer you get actually refers to an instance of your class. This is because
lua doesn't distinguish the two cases where you get the other operand as left hand value or right hand value.
Consider the following examples:</p>

<pre>
class 'my_class'

function my_class:__init(v)
	self.val = v
end
	
function my_class:__sub(v)
	return my_class(self.val - v.val)
end

function my_class:__tostring()
	return self.val
end
</pre>

<p>This will work well as long as you only subtracts instances of <tt>my_class</tt> with each other. But
If you want to be able to subtract ordinary numbers from your class too, you have to manually check the type
of <b>both</b> operands, including the self object.</p>

<pre>
function my_class:__sub(v)
	if (type(self) == 'number') then
		return my_class(self - v.val)

	elseif (type(v) == 'number') then
		return my_class(self.val - v)
	
	else
		-- assume both operands are instances of my_class
		return my_class(self.val - v.val)

	end
end
</pre>

<p>The reason why <tt>__sub</tt> is used as an example is because subtraction is not commutative (the
order of the operands matter). That's why luabind cannot change order of the operands to make the
self reference always refer to the actual class instance.</p>

<p>If you have two different lua classes with an overloaded operator, the operator of the right hand
side type will be called. If the other operand is a C++ class with the same operator overloaded, it
will be prioritized over the lua class' operator. If none of the C++ overloads matches, the lua
class' operator will be called.</p>

<h2><a name="class_lua_finalizers"></a>finalizers</h2>

<p>If an object needs to perform actions when it's collected we provide
a <tt>__finalize</tt> function that can be overridden in lua-classes.
The __finalize functions will be called on all classes in the inheritance
chain, starting with the most derived type.</p>

<pre>
...

function lua_testclass:__finalize()
	-- called when the an object is collected
end
</pre>

<h1><a name="exceptions"></a>Exceptions</h1>
<p>If any of the functions you register throws an exception when called, that exception will be caught
by luabind and converted to an error string and <tt>lua_error</tt> will be invoked. If the exception
is a <tt>std::exception</tt> or a <tt>const&nbsp;char*</tt> the string that is pushed on the lua stack,
as error message, will be the <tt>what()</tt> or the string itself respectively. If the exception
is unknown, a generic string saying that the function threw an exception will be pushed.</p>

<p>Exceptions thrown from user defined functions have to be caught by luabind. If they weren't they
would be thrown through lua itself, which is usually compiled as C code and doesn't support the
stack-unwinding that exceptions imply.</p>

<p>Any function that invokes lua code may throw <tt>luabind::error</tt>. This exception means that a lua
run-time error occurred. The error message is found on top of the lua stack. The reason why the
exception doesn't contain the error string itself is because it would then require heap allocation
which may fail. If an exception class throws an exception while it is being thrown itself, the
application will be terminated.</p>

<p>Error's synopsis is:</p>

<pre>
class error: std::exception
{
public:
	error(lua_State*);
	lua_State* state() const throw();
	virtual const char* what() const throw();
};
</pre>

<p>The state function returns a pointer to the lua state in which the error was thrown. This pointer
may be invalid if you catch this exception after the lua state is destructed. If the lua state is
valid you can use it to retrieve the error message from the top of the lua stack.</p>

<p>An example of where the lua state pointer may point to an invalid state follows:</p>

<pre>
struct lua_state
{
	lua_state(lua_State* L): m_L(L) {}
	~lua_state() { lua_close(m_L); }
	operator lua_State*() { return m_L; }
	lua_State* m_L;
};

int main()
{
	try
	{
		lua_state L = lua_open();
		/* ... */
	}
	catch(luabind::error&amp; e)
	{
		lua_State* L = e.state();
		// L will now point to the destructed
		// lua state and be invalid
		/* ... */
	}
}
</pre>

<p>There's another exception that luabind may throw. <tt>luabind::cast_failed</tt>, this exception
is thrown from <a href="#lua_fun"><tt>call_function</tt></a>, <a href="#lua_fun"><tt>call_member</tt></a> or when <a href="#functor"><tt>functor</tt></a> is invoked.
It means that the return value from the lua function couldn't be converted to a C++ value. It is
also thrown from <a href="#object_functions"><tt>object_cast</tt></a> if the cast cannot be made.</p>

<p>The synopsis for <tt>luabind::cast_failed</tt> is:</p>

<pre>
class cast_failed: std::exception
{
public:
	cast_failed(lua_State*);
	lua_State* state() const throw();
	LUABIND_TYPE_INFO info() const throw();
	virtual const char* what() const throw();
};
</pre>

<p>Again, the <tt>state</tt> member function returns a pointer to the lua state where the error occurred.
See the example above to see where this pointer may be invalid.</p>

<p>The <tt>info</tt> member function returns the user defined <a href="#luabind_type_info"><tt>LUABIND_TYPE_INFO</tt></a>, which
defaults to a <tt>const&nbsp;std::type_info*</tt>. This type info describes the type that we tried
to cast a lua value to.</p>

<p>If you have defined <a href="#luabind_no_exceptions"><tt>LUABIND_NO_EXCEPTIONS</tt></a> none of these exceptions will be thrown,
instead you can set two callback functions that are called instead. These two functions are only defined if <a href="#luabind_no_exceptions"><tt>LUABIND_NO_EXCEPTIONS</tt></a> are defined.</p>

<h3><a name="set_error_callback"></a><tt>luabind::set_error_callback(void(*)(lua_State*))</tt></h3>
<p>The function you set will be called when a runtime-error occur in lua code. You can find an
error message on top of the lua stack. This function is not expected to return, if it does
luabind will call <tt>std::terminate()</tt>.</p>

<h3><a name="set_cast_failed_callback"></a><tt>luabind::set_cast_failed_callback(void(*)(lua_State*, LUABIND_TYPE_INFO))</tt></h3>

<p>The function you set is called instead of throwing <tt>cast_failed</tt>. This function is not expected to return, if it does luabind will call <tt>std::terminate()</tt>.</p>


<h1><a name="policies"></a>Parameter policies</h1>

<p>Sometimes it is necessary to control how luabind passes 
arguments and return value, to do this we have policies. These are the 
policies that can be used:</p>

<h2><a name="policies_copy"></a>copy</h2>

<p>This will make a copy of the parameter. This is the 
default behavior when passing parameters by-value. Note that this can only be 
used when passing from C++ to lua. This policy requires that the parameter
type has a copy constructor.</p>

<p>To use this policy you need to include <tt>&lt;luabind/copy_policy.hpp&gt;</tt>.</p>

<h2><a name="policies_adopt"></a>adopt</h2>

<p>This will transfer ownership of the parameter.</p>
<p>Consider making a factory function in C++ and exposing 
it to lua:</p><pre>base* create_base()
{
	return new base();
}
</pre>

<pre>
module(L)
[
	def("create_base", create_base)
];
</pre>

<p>Here we need to make sure lua understands that it should 
adopt the pointer returned by the factory-function. This can be done using the 
adopt-policy.</p>

<pre>
module(L)
[
	def(L, "create_base", adopt(return_value))
];
</pre>

<p>To specify multiple policies we just separate them with '+'.</p>

<pre>
base* set_and_get_new(base* ptr)
{
	base_ptrs.push_back(ptr);
	return new base();
}
</pre>

<pre>
module(L)
[
	def(L, "set_and_get_new", &amp;set_and_get_new, adopt(return_value) + adopt(_1))
];
</pre>

<p>When lua adopts a pointer, it will call <tt>delete</tt> on it. This means that it cannot adopt pointers allocated with
another allocator than <tt>new</tt> (no <tt>malloc</tt> for example).</p>

<p>To use this policy you need to include <tt>&lt;luabind/adopt_policy.hpp&gt;</tt>.</p>

<h2><a name="policies_dependency"></a>dependency</h2>

<p>The dependency policy is used to create life-time dependencies between values. Consider the following example:</p>

<pre>
struct A
{
	B m_member;

	const B&amp; get_member()
	{
		return m_member;
	}
};
</pre>

<p>When wrapping this class, we would do something like:</p>

<pre>
module(L)
[
	class_&lt;A&gt;("A")
		.def(constructor&lt;&gt;())
		.def("get_member", &amp;A::get_member)
];
</pre>

<p>However, since the return value of get_member is a reference to a member of A, this will create
some life-time issues. For example:</p>

<pre>
a = A()
b = a:get_member() -- b points to a member of a
a = nil
collectgarbage(0)  -- since there are no references left to a, it is removed
                   -- at this point, b is pointing into a removed object
</pre>

<p>When using the dependency-policy, it is possible to tell luabind to tie the lifetime of one
object to another, like this:</p>

<pre>
module(L)
[
	class_&lt;A&gt;("A")
		.def(constructor&lt;&gt;())
		.def("get_member", &amp;A::get_member, dependency(result, self))
];
</pre>

<p>This will create a dependency between the return-value of the function, and the self-object. This means
that the self-object will be kept alive as long as the result is still alive.</p>

<pre>
a = A()
b = a:get_member() -- b points to a member of a
a = nil
collectgarbage(0)  -- a is dependent on b, so it isn't removed
b = nil
collectgarbage(0)  -- all dependencies to a gone, a is removed
</pre>

<p>To use this policy you need to include <tt>&lt;luabind/dependency_policy.hpp&gt;</tt>.</p>

<h2><a name="policies_return_ref"></a>return_reference_to</h2>

<p>It is very common to return references to arguments or the this-pointer to allow for chaining in C++.</p>
<pre>
struct A
{
	float m_val;

	A&amp; set(float v)
	{
		m_val = v;
		return *this;
	}
};
</pre>

<p>When luabind generates code for this, it will create a new object for the return-value, pointing to the self-object. This
isn't a problem, but could be a bit inefficient. When using the return_reference_to-policy we have the ability to tell
luabind that the return-value is already on the lua stack.</p>

<pre>
module(L)
[
	class_&lt;A&gt;("A")
		.def(constructor&lt;&gt;())
		.def("set", &amp;A::set, return_reference_to(self))
];	
</pre>

<p>Instead of creating a new object, luabind will just copy the object that is already on the stack.</p>
<p>NOTE! This policy ignores all type information and should be used only it situations where the parameter type
is a perfect match to the return-type (such as in the example).</p>

<p>To use this policy you need to include <tt>&lt;luabind/return_reference_to_policy.hpp&gt;</tt>.</p>

<h2><a name="policies_out"></a>out_value</h2>

<p>This policy makes it possible to wrap functions that take non const references as its parameters with the intention to write return values to them.</p>

<pre>
void f(float&amp; val) { val = val + 10.f; }
</pre>
or
<pre>
void f(float* val) { *val = *val + 10.f; }
</pre>

<p>Can be wrapped by doing:</p>

<pre>
module(L)
[
	def("f", &amp;f, out_value(_1))
];
</pre>

<p>When invoking this function from lua it will return the value assigned to its parameter.</p>

<pre>
a = f(10) -- a is now 20
</pre>
		
<p>When this policy is used in conjunction with user define types we often need to do ownership transfers.</p>
		
<pre>
struct A
{
};

void f(A*&amp; obj) { obj = new A(); }
or
void f(A** obj) { *obj = new A(); }
</pre>

<p>Here we need to make sure luabind takes control over object returned, for this we use the <tt>adopt</tt> policy</p>

<pre>
module(L)
[
	class_&lt;A&gt;("A"),

	def("f", &amp;f, out_value(_1, adopt(_2)))
];
</pre>

<p>Here we are using <tt>adopt</tt> as an internal policy to <tt>out_value</tt>. The index specified, <tt>_2</tt>, means adopt will be used to convert the value back to lua. Using <tt>_1</tt> means the policy will be used when converting from lua to C++.</p>

<p>To use this policy you need to include <tt>&lt;luabind/out_value_policy.hpp&gt;</tt>.</p>

<h2><a name="policies_pure_out"></a>pure_out_value</h2>

<p>This policy works in exactly the same way as <tt>out_value</tt>, except that it replaces the parameters with default-constructed
objects.</p>

<pre>
void get(float&amp; x, float&amp; y)
{
	x = 3.f;
	y = 4.f;
}
</pre>
<pre>
module(L)
[
	def("get", &amp;get, pure_out_value(_1) + pure_out_value(_2))
];
</pre>
<pre>
x,y = get()
print(x,y)  -- prints '3   4'
</pre>

<p>Like out_value, it is possible to specify an internal policy used then converting the values back to lua.</p>

<pre>
void get(test_class*&amp; obj)
{
	obj = new test_class();
}
</pre>
<pre>
module(L)
[
	def("get", &amp;get, pure_out_value(_1, adopt(_1)))
];
</pre>

<h2><a name="policies_discard_result"></a>discard_result</h2>
		
<p>This is a very simple policy which makes it possible to throw away the value returned by a C++ function, instead of converting it to lua. This example makes sure the <tt>this</tt> reference never gets converted to lua</p>
		
<pre>
struct simple
{
	simple&amp; set_name(const std::string&amp; n)
	{
		name = n;
		return *this;
	}

	std::string name;
};
</pre>
<pre>
module(L)
[
	class_&lt;simple&gt;("simple")
		.def("set_name", &amp;simple::set_name, discard_result)
];
</pre>
		
<p>To use this policy you need to include <tt>&lt;luabind/discard_result.hpp&gt;</tt>.</p>

<h2><a name="policies_return_stl_iterator"></a>return_stl_iterator</h2>

<p>This policy converts an STL container to a generator function that can be used in lua to
iterate over the container. It works on any container that defines <tt>begin()</tt> and <tt>end()</tt>
member functions (they have to return iterators). It can be used like this:</p>

<pre>
struct A
{
	std::vector&lt;std::string&gt; names;
};
</pre>
<pre>
module(L)
[
	class_&lt;A&gt;("A")
		.def_readwrite("names", &amp;A::names, return_stl_iterator)
];
</pre>

<p>The lua code to iterate over the container:</p>

<pre>
a = A()

for name in a.names do
  print(name)
end
</pre>

<p>To use this policy you need to include <tt>&lt;luabind/iterator_policy.hpp&gt;</tt></p>

<h2><a name="policies_yield"></a>yield</h2>

<p>This policy will cause the function to always yield the current
thread when returning. See the lua manual for restrictions on yield.</p>

<pre>
module(L)
[
	def("f", &amp;f, yield)
];
</pre>

<h2><a name="policies_custom"></a>custom</h2>

<p>The policies don't have a stable API yet. See the examples directory.</p>

<h2><a name="policies_user_converter"></a>user defined converter</h2>

<p>The policies don't have a stable API yet. See the examples directory.</p>

<h1><a name="config"></a>Configuration</h1>

<p>There are a number of configuration options available when building luabind. It is very important
that your project has the exact same conmfiguration options as the ones given when the library was build!
The exceptions are the <tt>LUABIND_MAX_ARITY</tt> and <tt>LUABIND_MAX_BASES</tt> which are template-based
options and only matters when you use the library (which means they can differ from the settings of the
library).</p>

<p>The default settings can be found in <tt>luabind/config.hpp</tt> they will be used if no other settings
are given.</p>

<p>If you want to change the settings of the library, you can modify the config-file. It is included and used
by all make-files. You can change paths to lua and boost in there as well.</p>

<h3><tt>LUABIND_MAX_ARITY</tt></h3>
			<p>Controls the maximum arity of functions that are registered
			with luabind. You can't register functions that takes more
			parameters than the number this macro is set to. It defaults
			to 5, so, if your functions have greater arity you have to
			redefine it. A high limit will increase compilation time.</p>
<h3><tt>LUABIND_MAX_BASES</tt></h3>
			<p>Controls the maximum number of classes one class can derive from
			in luabind (the number of classes specified within
			<tt>bases&lt;&gt;</tt>). <tt>LUABIND_MAX_BASES</tt> defaults to 4.
			A high limit will increase compilation time.</p>
<h3><tt>LUABIND_NO_ERROR_CHECKING</tt></h3>
			<p>If this macro is defined, all the lua code is expected only to make
			legal calls. If illegal function calls are made (e.g. giving parameters
			that doesn't match the function signature) they will not be detected
			by luabind and the application will probably crash. Error checking
			could be disabled when shipping a release build (given that no end-user
			has access to write custom lua code). Note that function parameter
			matching will be done if a function is overloaded, since otherwise it's
			impossible to know which one was called. Functions will still be able
			to throw exceptions when error checking is disabled.</p>

			<p>Functions will still be able to throw exceptions, they will be
			caught by luabind and propagated with <tt>lua_error()</tt>.</p>

			
<h3><tt>LUABIND_DONT_COPY_STRINGS</tt></h3>
			<p>If this macro is defined, luabind will expect that all strings given
			to the def() methods are static constant strings (given as string
			constants for example). luabind will not copy the strings if you
			enable this setting, but just keep the char pointers. This may be
			especially useful for embedded systems or consoles where heap
			allocations should be minimized.</p>

			
<a name="luabind_no_exceptions"></a><h3><tt>LUABIND_NO_EXCEPTIONS</tt></h3>
			<p>This define will disable all usage of try, catch and throw in
			luabind. This will in many cases disable run-time errors, when
			performing invalid casts or calling lua-functions that fails or
			returns values that cannot be converted by the given policy.
			luabind requires that no function called directly or indirectly
			by luabind throws an exception (throwing exceptions through
			lua has undefined behavior).</p>

			<p>Where exceptions are the only way to get an error report from
			luabind, they will be replaced with calls to the callback
			functions set byt <a href="#set_error_callback"><tt>set_error_callback()</tt></a>
			and <a href="#set_cast_failed_callback"><tt>set_cast_failed_callback()</tt></a>.</p>
			
<a name="luabind_type_info"></a><h3><tt>LUABIND_TYPE_INFO</tt><br>
<tt>LUABIND_TYPE_INFO_EQUAL(i1,i2)</tt><br>
<tt>LUABIND_TYPEID(t)</tt><br>
<tt>LUABIND_INVALID_TYPE_INFO</tt></h3>

			<p>If you don't want to use the RTTI supplied by C++
			you can supply your own type-info structure with the
			LUABIND_TYPE_INFO define. Your type-info structure must
			be copyable and must be able to compare itself against
			other type-info structures. You supply the compare
			function through the LUABIND_TYPE_INFO_EQUAL()
			define. It should compare the two type-info structures
			it is given and return true if they represent the same type
			and false otherwise. You also have to supply a function
			to generate your type-info structure. You do this through
			the LUABIND_TYPEID() define. It should return your type-info
			structure and it takes a type as its parameter. That is,
			a compile time parameter. LUABIND_INVALID_TYPE_INFO macro
			should be defined to an invalid type. No other type should
			be able to produce this type info. To use it you probably
			have to make a traits class with specializations for all
			classes that you have type-info for. Like this:</p>
			
			<pre>
class A;
class B;
class C;

template&lt;class T&gt; struct typeinfo_trait;

template&lt;&gt; struct typeinfo_trait&lt;A&gt; { enum { type_id = 0 }; };
template&lt;&gt; struct typeinfo_trait&lt;B&gt; { enum { type_id = 1 }; };
template&lt;&gt; struct typeinfo_trait&lt;C&gt; { enum { type_id = 2 }; };
			</pre>
			
			<p>If you have set up your own RTTI system like this (by using integers to identify types)
			you can have luabind use it with the following defines</p>
			
			<pre>
#define LUABIND_TYPE_INFO int
#define LUABIND_TYPE_INFO_EQUAL(i1, i2) i1 == i2
#define LUABIND_TYPEID(t) typeinfo_trait&lt;t&gt;::type_id
#define LUABIND_INVALID_TYPE_INFO -1
			</pre>
			
			<p>The default behavior, if you don't define any of these three, is to use the built-in
			RTTI support in C++.</p>
			
			<pre>
#define LUABIND_TYPE_INFO const std::type_info*
#define LUABIND_TYPEID(t) &amp;typeid(t)
#define LUABIND_TYPE_INFO_EQUAL(i1, i2) *i1 == *i2
#define LUABIND_INVALID_TYPE_INFO &amp;typeid(detail::null_type)
			</pre>

			<p>currently the type given through LUABIND_TYPE_INFO must be less-than comparable!</p>
<h3><tt>NDEBUG</tt></h3>
			<p>This define will disable all asserts and should be defined in a release build.</p>


<h1><a name="implementation_notes"></a>Implementation notes</h1>

<p>The classes and objects are implemented as user data in lua. To make sure that
the user data really is the internal structure it is supposed to be, we tag their
metatables. A user data who's metatable contains a boolean member named
<tt>"__luabind_classrep"</tt> is expected to be a class exported by luabind.
A user data who's metatable contains a boolean member named <tt>"__luabind_class"</tt>
is expected to be an instantiation of a luabind class.</p>

<p>This means that if you make your own user data and tags its metatable with the
exact same names, you can very easily fool luabind and crash the application.</p>

<p>In the lua registry, luabind keeps an entry called "<tt>__luabind_classes</tt>"
and "<tt>__luabind_free_functions</tt>". These should not be removed or overwritten.</p>

<p>In the global table, a variable called <tt>super</tt> is used every time a constructor
in a lua-class is called. This is to make it easy for that constructor to call its base
class' constructor. So, if you have a global variable named <tt>super</tt> it may very
well be overwritten. This is probably not the best solution, and this restriction may very
well be removed in the future.</p>

<p>Inside the <tt>luabind</tt> namespace, there's another namespace called <tt>detail</tt>.
This namespace contains non-public classes and are not supposed to be used directly.</p>

<h1><a name="error_messages"></a>Error messages</h1>

<ul>
	<li>cannot set attribute '<i>&lt;class-name&gt;</i>.<i>&lt;attribute-name&gt;</i>'
	<p>There is no data member named <i>&lt;attribute-name&gt;</i> in the class <i>&lt;class-name&gt;</i>, or
	there's no setter-method registered on that property name. See the <a href="#class_property">properties</a> section.</p>

	<li><i>&lt;class-name&gt;</i>() threw an exception
	<li><i>&lt;class-name&gt;</i>:<i>&lt;function-name&gt;</i>() threw an exception
	<p>The class' constructor or member function threw an unknown exception. Known exceptions are <tt>const&nbsp;char*</tt>,
	<tt>std::exception</tt>. See the <a href="#exceptions">exceptions</a> section.</p>

	<li>no overload of '<i>&lt;class-name&gt;</I>:<i>&lt;function-name&gt;</i>' matched the arguments (&lt;<i>parameter-types&gt;)</i>
	<li>no match for function call '<i>&lt;function-name&gt;</i>' with the parameters (<i>&lt;parameter-types&gt;</i>)
	<li>no constructor of <i>&lt;class-name&gt;</i> matched the arguments (<i>&lt;parameter-types&gt;</i>) 
	<li>no operator <i>&lt;operator-name&gt;</i> matched the arguments (<i>&lt;parameter-types&gt;</i>)
	<p>No function/operator with the given name takes the parameters you gave it. You have either misspelled the function name,
	or given it incorrect parameters. This error is followed by a list of possible candidate functions to help you figure out what
	parameter has the wrong type. If the candidate list is empty there's no function at all with that name. See the
	<a href="#fun_sigmatch">signature matching</a> section.</p>
	
	<li>call of overloaded '<i>&lt;class-name&gt;</i>:<i>&lt;function-name&gt;</i>(&lt;<i>parameter-types&gt;</i>)' is ambiguous
	<li>ambiguous match for function call '<i>&lt;function-name&gt;</i>' with the parameters (<i>&lt;parameter-types&gt;</i>)
	<li>call of overloaded constructor '<i>&lt;class-name&gt;</i>(<i>&lt;parameter-types&gt;</i>)' is ambiguous 
	<li>call of overloaded operator <i>&lt;operator-name&gt;</i> (<i>&lt;parameter-types&gt;</i>) is ambiguous
	<p>This means that the function/operator you are trying to call has at least one other overload that matches the arguments
	just as good as the first overload.</p>

	<li>cannot derive from C++ class '<i>&lt;class-name&gt;</i>'. It does not have a wrapped type.
	<p>You are trying to derive a lua class from a C++ class that doesn't have a wrapped type. You have to give
	your C++ class a wrapped type when you register it with lua. See the <a href="#class_lua_derive">deriving in lua</a> section.</p>

	<li>derived class must call super on base
	<li>cannot set property '<i>&lt;class-name&gt;</i>.<i>&lt;attribute_name&gt;</i>' because it's read only
	<p>The attribute you are trying to set is registered as read only. If you want it to be writeable you have to change your
	class registration and use <tt>def_readwrite()</tt> instead of <tt>def_readonly()</tt>. Alternatively (if your attribute
	is a property with getter and setter functions), you have to give a setter function when declaring your attribute. See
	the <a href="#class_property">properties</a> section.</p>

	<li>no static '<i>&lt;enum-name&gt;</i>' in class '<i>&lt;class-name&gt;</i>'
	<p>You will get this error message if you are trying to access an enum that doesn't exist. Read about how to
	<a href="#class_enum">declare enums</a>.</p>

	<li>expected base class
	<p>You have written a malformed <a href="#class_lua">class definition in lua</a>. The format is:
	<tt>class&nbsp;'<i>&lt;class-name&gt;</i>'&nbsp;[<i>&lt;base-class&gt;</i>]</tt>. If you don't want to derive from
	a base class, you have to break the line directly after the class declaration.</p>
	
	<li>invalid construct, expected class name
	<p>You have written a malformed <a href="#class_lua">class definition in lua</a>. The <tt>class</tt> function expects
	a string as argument. That string is the name of the lua class to define.</p>
</ul>

<h1><a name="faq"></a>FAQ</h1>
<ul>
	<li><h3>What's up with __cdecl and __stdcall?</h3>
	
	<p>If you're having problem with functions that cannot be converted from
	<tt>'void&nbsp;(__stdcall&nbsp;*)(int,int)'</tt> to <tt>'void&nbsp;(__cdecl&nbsp;*)(int,int)'</tt>.
	You can change the project settings to make the compiler generate functions with
	<tt>__cdecl</tt> calling conventions. This is a problem in developer studio.</p>

	<li><h3>What's wrong with functions taking variable number of arguments?</h3>
	<p>You cannot register a function with ellipses in its signature. Since ellipses don't preserve
	type safety, those should be avoided anyway.</p>

	<li><h3>Internal structure overflow in VC</h3>
	<p>If you, in visual studio,  get <tt>fatal error C1204: compiler limit : internal
	structure overflow</tt>. You should try to split that compilation unit up
	in smaller ones.</p>

	<li><h3>What's wrong with precompiled headers in VC?</h3>
	<p>Visual Studio doesn't like anonymous namespaces in its precompiled headers. If you encounter this
	problem you can disable precompiled headers for the compilation unit (cpp-file) that uses luabind.</p>

	<li><h3>error C1076: compiler limit - internal heap limit reached in VC</h3>
	<p>In visual studio you will probably hit this error. To fix it you have to increase the internal heap
	with a command-line option. We managed to compile the test suit with /Zm300, but you may need a larger
	heap then that.</p>

	<li><h3>error C1055: compiler limit : out of keys in VC</h3>
	<p>It seems that this error occurs when too many <tt>assert()</tt> are used in a program, or more
	specifically, the <tt>__LINE__</tt> macro. It seems to be fixed by changing /ZI (Program database
	for edit and continue) to /Zi (Program database).</p>
	
	<li><h3>How come my executable is huge?</h3>
	<p>If you're compiling in debug mode, you will probably have a lot of debug-info and symbols (luabind
	consists of a lot of functions). Also, if built in debug mode, no optimizations were applied, luabind
	relies on that the compiler is able to inline functions. If you built in release mode, try running
	<tt>strip</tt> on your executable to remove export-symbols, this will trim down the size.</p>
	<p>Our tests suggests that cygwin's gcc produces much bigger executables compared to gcc on other 
	platforms and other compilers.</p>

	<li><h3>Can I register template classes with luabind?</h3>
	<p>Yes you can, but you can only register explicit instantiations of the class. Because there's no
	lua counterpart to C++ templates. For example, you can register an explicit instantiation of
	<tt>std::vector</tt> like this:</p>
	<pre>
module(L)
[
	class_&lt;std::vector&lt;int&gt;&nbsp;&gt;("vector")
		.def(constructor&lt;int&gt;)
		.def("push_back", &amp;std::vector&lt;int&gt;::push_back)
];
	</pre>
	<p>Note that the space between the two &gt; is required by C++.</p>

	<li><h3>Do I have to register destructors for my classes?</h3>
	<p>No, the destructor of a class is always called by luabind when an object is collected. Note that
	lua has to own the object to collect it. If you pass it to C++ and gives up ownership (with
	<a href="#policy_adopt">adopt</a> policy) it will no longer be owned by lua, and not collected.</p>
	<p>If you have a class hierarchy, you should make the destructor <tt>virtual</tt> if you want to
	be sure that the correct destructor is called (this apply to C++ in general).</p>

	<li><h3>Fatal Error C1063 compiler limit : compiler stack overflow in VC</h3>
	<p>VC6.5 chokes on warnings, if you are getting alot of warnings from your code try suppressing them
	with a pragma directive, this should solve the problem.</p>

</ul>

<h1><a name="future"></a>Future additions</h1>
<ul>
	<li>A mechanism for wrapping iterators with generators.
</ul>

<h1><a name="issues"></a>Known issues</h1>
<ul>
	<li>If one class registers two functions with the same name and the same signature,
	there's currently no error. The last registered function will be the one that's used.
	<li>In vc7, classes can not be called <tt>test</tt>.
	<li>Visual studio have problems selecting the correct overload of <tt>std::swap()</tt> for <tt>luabind::object</tt>.
</ul>

<h1><a name="acknowledgments"></a>Acknowledgments</h1>

<p>This library was written by <a href="mailto:dalwan01@student.umu.se">Daniel Wallin</a>
and <a href="mailto:c99ang@cs.umu.se">Arvid Norberg</a>. &copy; Copyright 2003. All rights reserved.</p>

<p>This library was inspired by Dave Abrahams'
<a href="http://www.boost.org/libs/python/doc/index.html">Boost.Python</a> library which can be found in the
<a href="http://www.boost.org">boost</a> library.</p>
<p>
	<a href="http://validator.w3.org/check/referer">
	<img style="border:0;width:88px;height:31px"
	src="http://www.w3.org/Icons/valid-html401"
	alt="Valid HTML 4.01!"></a>

	<a href="http://jigsaw.w3.org/css-validator/">
	<img style="border:0;width:88px;height:31px"
	src="http://jigsaw.w3.org/css-validator/images/vcss"
	alt="Valid CSS!"></a>

</p>

</body></html>

